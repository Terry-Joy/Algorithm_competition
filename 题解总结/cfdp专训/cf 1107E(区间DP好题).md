# cf 1107E(区间DP好题)

题意：

给你01串，每次你可以消去相同的字符并获得对应长度的值，问消去所有字符的贡献

思路：

神仙状态。首先考虑$dp[i][j]$为消去$[i,j]$后的贡献，考虑什么可以转移过去，我们发现如果只是单纯内部合并的都没有问题，但如果枚举$x$，$[i,x]和[x,j]$之间的贡献难以计算，此外当前状态无法终结，可能在未来被贡献。对于这种当前决策受未来影响的$dp$问题，我们预知未来的花费。暴力枚举某区间最后被消除的字符为$j$，$dp[i][j][k]$表示$[i,j]$被消除且$j$是在未来和右边被消出来的连续$k$块一起消除的。

转移就非常简单了

要么当前直接消除j和右边的，要么找到左边一个和$j$相同的$x$，下次再消

$dp[i][j][k]=max(dp[i][j-1][0]+a[k+1],dp[i][x][k+1]+dp[x+1][j-1])$

由于是最大值，初始化为0即可

我们可以发现，这种状态定义，一个意味着支票透支未来，一个意味着承诺兑现支票

启发：1、遇到当前决策受未来影响的时候，我们可以通过多记录状态预知未来的状态，从而把影响一直传递

2、区间DP中合并与未来有关的时候，可以多记录一维表示未来的状态，如$dp[i][j][k]$表示未来$j$和右边$k$个一起消除



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,a[105];
ll dp[105][105][105];
char s[105];
int main(){
    scanf("%d",&n);
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    for(int len=1;len<=n;++len){
        for(int i=1;i+len-1<=n;++i){
            int j=i+len-1;
            for(int k=0;k<n;++k){
                dp[i][j][k]=dp[i][j-1][0]+a[k+1];
                for(int x=i;x<j;++x){
                    if(s[x]==s[j]){
                        dp[i][j][k]=max(dp[i][j][k],dp[x+1][j-1][0]+dp[i][x][k+1]);
                    }
                }
            }
        }
    }
    cout<<dp[1][n][0]<<"\n";
    return 0;
}
```

