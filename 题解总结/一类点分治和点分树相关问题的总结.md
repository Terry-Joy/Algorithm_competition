# 一类点分治和点分树相关问题的总结

这些天刷了很多点分治和点分树的相关问题，来总结一下

首先这些问题是比较套路化的，

树上全路径问题，连通块问题的计数和判定，一般都是用到点分治/点分树。

统计的办法有两种，一种是考虑容斥，一般用于计数，一种是枚举子树统计。

前者好写常数较大，后者常数较小，细节较多

一般求路径长度<=k的数目,每个路径长度准确数目，常用第一种，**一般还可能通过排序形成偏序关系，利用数据结构维护，常见的有树状数组、单调队列按秩合并维护**

枚举子树统计的话，一般是这两种方法，要么当前根不保留，计算的时候保留，要么保留，计算的时候去掉当前根，具体问题具体分析，此外，一定要注意端点的贡献->**考虑分治重心作为单个端点，单条链。**另外，两者都要注意情空当前层重心的贡献

![image-20210415140836486](C:\Users\98753\AppData\Roaming\Typora\typora-user-images\image-20210415140836486.png)

与连通块有关的问题呢，如果是多次询问 $or$ 修改 ，我们就得拿出点分树了，每个重心维护自己分治的区域，更新的话只对点分树上的祖先路径有贡献，可以把深度压到$O(logn)$层常见的套路就是每个点维护两个数据结构，一个是自己对自己的贡献，一个是自己对父亲的贡献，也是比较套路的题目。下面列出一些题目