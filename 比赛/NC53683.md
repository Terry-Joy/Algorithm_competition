##### NC53683  

**题意：**  
一行烈焰

0：这个格子没有烈焰，且其左右两个格子均没有烈焰   
1：这个格子没有烈焰，且其左右两个格子中只有一个烈焰   
2：这个格子没有烈焰，且其左右两个格子中均有烈焰   
*：这个格子有烈焰   
？：未告诉你本格情况   

**思路：**  
显然从左到右作为阶段，用dp解决，容易想到当前位置受到i-1和i+1的讨论，状态最重要的是有无烈焰，前一个的约束转移的时候自然就有了，所以我们只需要考虑后一个，$dp[i][0/1][0/1]$ 表示到第i个位置，当前有无火焰，下一个有无火焰，要记住一个dp的最关键的问题，当前状态只需要考虑从前状态的影响！后面那个到底有没有，会在后面的子问题被解决掉，你就安心转移就好了，转移很显然，看代码就懂了

```c++
#include<bits/stdc++.h>

using namespace std;
const int maxn=1e6+5;
typedef long long ll;
char s[maxn];
const ll mod=1e9+7;
ll dp[maxn][2][2];
int main(){ 
    scanf("%s",s+1);
    int n=strlen(s+1);
    dp[0][0][0]=1;dp[0][0][1]=1;
    for(int i=1;i<=n;++i){ 
        if(s[i]=='0'){ 
            dp[i][0][0]+=dp[i-1][0][0];
            dp[i][0][0]%=mod;
        }else if(s[i]=='1'){ 
            dp[i][0][1]+=dp[i-1][0][0];
            dp[i][0][0]+=dp[i-1][1][0];
            dp[i][0][1]%=mod;
            dp[i][0][0]%=mod;
        }else if(s[i]=='2'){ 
            dp[i][0][1]+=dp[i-1][1][0];
            dp[i][0][1]%=mod;
        }else if(s[i]=='*'){ 
            dp[i][1][0]+=(dp[i-1][0][1]+dp[i-1][1][1]);
            dp[i][1][0]%=mod;
            dp[i][1][1]+=(dp[i-1][0][1]+dp[i-1][1][1]);
            dp[i][1][1]%=mod;
        }else if(s[i]=='?'){ 
            dp[i][1][0]+=(dp[i-1][0][1]+dp[i-1][1][1]);
            dp[i][1][1]+=(dp[i-1][0][1]+dp[i-1][1][1]);
            dp[i][0][0]+=(dp[i-1][0][0]+dp[i-1][1][0]);
            dp[i][0][1]+=(dp[i-1][0][0]+dp[i-1][1][0]);
            dp[i][1][0]%=mod,dp[i][1][1]%=mod,dp[i][0][0]%=mod,dp[i][0][1]%=mod;
        }
    }
    cout<<(dp[n][1][0]+dp[n][0][0])%mod<<endl;
    return 0;
}

```

